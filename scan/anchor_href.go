package scan

import (
	"bytes"
	"regexp"

	"golang.org/x/net/html"
)

// LegacyAnchorGallery scans pictures like <a href="picture2.jpg" title="picture2">picture 2</a>
type LegacyAnchorGallery struct {
	source []byte
	node   *html.Node
}

// NewLegacyAnchorGallery creates a new gallery
func NewLegacyAnchorGallery(source []byte) (Gal, error) {
	node, err := html.Parse(bytes.NewReader(source))
	if err != nil {
		return nil, err
	}
	return &LegacyAnchorGallery{
		source: source,
		node:   node,
	}, nil
}

// HasDetection returns true when the current type of gallery can be detected
func (g *LegacyAnchorGallery) HasDetection() bool {
	return false
}

// Match returns true if this profile *can* be a match for the current file.
// if there's no gallery detection, it returns true to try to find images
func (g *LegacyAnchorGallery) Match() bool {
	return true
}

// GeneratedBy returns the name of the gallery generator (if available).
// It returns an empty string if not available
func (g *LegacyAnchorGallery) GeneratedBy() string {
	pattern := regexp.MustCompile(`<!--\s*Generated by\s*(.*?)\s*-->`)
	match := pattern.FindSubmatch(g.source)
	if match == nil || len(match) != 2 {
		return ""
	}
	return string(match[1])
}

// Find returns a list of images found in this gallery
func (g *LegacyAnchorGallery) Find() []string {
	pictures := make([]string, 0)

	var f func(*html.Node)
	f = func(n *html.Node) {
		if picture, found := getPictureAttribute(n, "a", "href"); found {
			pictures = append(pictures, picture)
		}
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			f(c)
		}
	}
	f(g.node)
	return pictures
}

// Verify interfaces
var (
	_ Gal        = &LegacyAnchorGallery{}
	_ GalFactory = NewLegacyAnchorGallery
)
